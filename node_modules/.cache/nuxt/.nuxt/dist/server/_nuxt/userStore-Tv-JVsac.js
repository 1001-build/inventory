import { defineStore } from "pinia";
import posthog from "posthog-js";
import { u as useShowToast } from "./useShowToast-CtYAVfjv.js";
import { ERROR_CODES } from "/Users/alsey89/Documents/code/personal/fullstack-nuxt-cf-template/shared/error/codes";
import { e as useRuntimeConfig, n as navigateTo, a as useI18n, i as useRequestEvent, k as useUserSession } from "../server.mjs";
const redirectConfig = {
  [ERROR_CODES.AUTH_REQUIRED]: { path: "/auth/signin" },
  [ERROR_CODES.INVALID_TOKEN]: { path: "/auth/signin" },
  [ERROR_CODES.TOKEN_EXPIRED]: { path: "/auth/signin" },
  [ERROR_CODES.TENANT_MISMATCH]: { path: "/auth/signin" }
};
const actionConfig = {
  [ERROR_CODES.EMAIL_NOT_CONFIRMED]: { path: "/auth/email/resend" },
  [ERROR_CODES.ACCOUNT_INACTIVE]: { path: "/support" },
  [ERROR_CODES.EMAIL_EXISTS]: { path: "/auth/signin" },
  [ERROR_CODES.INTERNAL_ERROR]: { path: "/support" },
  [ERROR_CODES.DATABASE_ERROR]: { path: "/support" }
};
function getErrorMessage(code) {
  const { t } = useI18n();
  const errorKey = `errors.${code}`;
  const message = {
    title: t(`${errorKey}.title`),
    description: t(`${errorKey}.description`)
  };
  const redirect = redirectConfig[code];
  if (redirect) {
    message.shouldRedirect = true;
    message.redirectTo = redirect.path;
  }
  const actionPath = actionConfig[code];
  if (actionPath && t(`${errorKey}.action.label`)) {
    message.action = {
      label: t(`${errorKey}.action.label`),
      onClick: () => {
        navigateTo(actionPath.path);
        return true;
      }
    };
  }
  return message;
}
function handleApiError(error, options = {}) {
  const config = useRuntimeConfig();
  const isDebugMode = config.public.debugMode;
  const showToast = useShowToast();
  const { blockRedirect = false, customMessage, onError } = options;
  const status = error.response?.status || 500;
  const errorData = error.response?._data;
  const code = errorData?.error?.code || "UNKNOWN_ERROR";
  const serverMessage = errorData?.error?.message;
  const traceID = errorData?.error?.traceID;
  if (isDebugMode) {
    console.error("API Error:", {
      status,
      code,
      serverMessage,
      traceID,
      rawError: error
    });
  }
  const errorConfig = getErrorMessage(code);
  showToast({
    title: errorConfig.title,
    description: customMessage || errorConfig.description,
    action: errorConfig.action
  });
  if (!blockRedirect && errorConfig.shouldRedirect && errorConfig.redirectTo) {
    navigateTo(errorConfig.redirectTo);
  }
  if (onError) {
    onError(code);
  }
  return {
    code,
    status,
    message: serverMessage || errorConfig.description,
    traceID
  };
}
function useSubdomain() {
  const host = useRequestEvent()?.node?.req?.headers.host ?? "";
  const hostname = host.split(":")[0];
  const parts = hostname.split(".");
  return parts.length > 2 ? parts[0] : null;
}
function useExtendedFetch() {
  const baseUrl = useRuntimeConfig().public.apiUrl;
  async function simpleFetch(path, options = {}) {
    const requestId = crypto.randomUUID();
    const subdomain = useSubdomain();
    const headers = {
      "Content-Type": "application/json",
      "X-Request-Id": requestId,
      "X-Tenant-Id": subdomain,
      ...options.headers
    };
    const res = await $fetch.raw(path, {
      ...options,
      baseURL: baseUrl,
      credentials: "include",
      headers
    });
    return { status: res.status, ok: res.ok, payload: res._data };
  }
  async function extendedFetch(path, options = {}, blockRedirect = false) {
    try {
      return await simpleFetch(path, options);
    } catch (error) {
      handleApiError(error, { blockRedirect });
    }
  }
  return { simpleFetch, extendedFetch };
}
const useUserStore = defineStore("user-store", {
  state: () => ({
    // Local UI state
    // theme preference: 'light' | 'dark'
    theme: "light",
    // User profile data from session
    userProfile: null,
    isLoading: false,
    error: null
  }),
  getters: {},
  actions: {
    async signin({ email, password, redirectTo = "/" } = {}) {
      this.isLoading = true;
      const showToast = useShowToast();
      const { extendedFetch } = useExtendedFetch();
      const { fetch: fetchSession } = useUserSession();
      const { status, payload } = await extendedFetch("/v1/auth/signin", {
        method: "POST",
        body: {
          email,
          password
        }
      });
      if (status === 200) {
        await fetchSession();
        showToast({
          title: "Success",
          description: "You are now logged in."
        });
        posthog.identify(payload.data.user.email, {
          user_id: payload.data.user.id,
          email: payload.data.user.email,
          first_name: payload.data.user.firstName,
          last_name: payload.data.user.lastName
        });
        this.isLoading = false;
        return navigateTo(redirectTo);
      } else {
        this.isLoading = false;
        return false;
      }
    },
    async signup({ firstName, lastName, email, password, passwordConfirmation } = {}) {
      this.isLoading = true;
      const showToast = useShowToast();
      const { extendedFetch } = useExtendedFetch();
      const { status } = await extendedFetch("/v1/auth/signup", {
        method: "POST",
        body: {
          firstName,
          lastName,
          email,
          password,
          passwordConfirmation
        }
      });
      if (status === 200 || status === 201) {
        showToast({
          title: "Account Created",
          description: "Please check your email to verify your account before signing in."
        });
        posthog.capture("user_signed_up", {
          email
        });
        this.isLoading = false;
        return navigateTo("/auth/signin");
      } else {
        this.isLoading = false;
        return false;
      }
    },
    setTheme(theme) {
      const allowed = ["light", "dark"];
      if (!allowed.includes(theme)) return;
      this.theme = theme;
    },
    async fetchUserProfile() {
      const { extendedFetch } = useExtendedFetch();
      try {
        const { status, payload } = await extendedFetch("/v1/user/profile", {
          method: "GET"
        });
        if (status === 200) {
          this.userProfile = payload.data;
        }
      } catch (error) {
        console.error("Failed to fetch user profile:", error);
        this.userProfile = null;
      }
    },
    async signout({ redirectTo = "/auth/signin" } = {}) {
      this.isLoading = true;
      const showToast = useShowToast();
      const { clear } = useUserSession();
      const { extendedFetch } = useExtendedFetch();
      await extendedFetch("/v1/auth/signout", {
        method: "POST"
      });
      await clear();
      this.userProfile = null;
      posthog.reset();
      this.isLoading = false;
      this.error = null;
      showToast({
        title: "Success",
        description: "You have signed out."
      });
      return navigateTo(redirectTo);
    },
    async requestPasswordReset({ email } = {}) {
      this.isLoading = true;
      const showToast = useShowToast();
      const { extendedFetch } = useExtendedFetch();
      const { status } = await extendedFetch("/v1/auth/password/reset/request", {
        method: "POST",
        body: {
          email
        }
      });
      if (status === 200) {
        showToast({
          title: "Reset Email Sent",
          description: "Please check your email for password reset instructions."
        });
        this.isLoading = false;
        return navigateTo("/auth/signin");
      } else {
        this.isLoading = false;
        return false;
      }
    },
    async resetPassword({ token, newPassword, newPasswordConfirmation } = {}) {
      this.isLoading = true;
      const showToast = useShowToast();
      const { extendedFetch } = useExtendedFetch();
      const { status } = await extendedFetch("/v1/auth/password/reset", {
        method: "PUT",
        body: {
          token,
          newPassword,
          newPasswordConfirmation
        }
      });
      if (status === 200) {
        showToast({
          title: "Password Reset Successfully",
          description: "You can now sign in with your new password."
        });
        this.isLoading = false;
        return navigateTo("/auth/signin");
      } else {
        this.isLoading = false;
        return false;
      }
    }
  },
  persist: {
    omit: ["isLoading", "error", "userProfile"]
  }
});
export {
  useUserStore as u
};
//# sourceMappingURL=userStore-Tv-JVsac.js.map
